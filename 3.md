# 三、随机变量

许多数据科学涉及数值变量，它的观察值取决于几率。其他值提供的变量的预测值，随机样本中观察到的不同类别个体的数量，以及自举样本的中值，仅仅是几个例子。 您在 Data8 中看到了更多例子。

在概率论中，随机变量是在结果空间上定义的数值函数。 也就是说，函数的定义域是`Ω`，它的值域是实数行。 随机变量通常用靠后的字母表示，如`X`和`Y`。

## 结果空间上的函数

随机抽样可以看做重复的随机试验，因此许多结果空间由序列组成。代表硬币投掷两次的结果空间是：

$\Omega = \{ \text{HH, HT, TH, TT} \}$

如果你投掷 10 次，结果空间将包含 10 个元素的 210 个序列，其中每个元素是`H`或`T`。手动列出结果比较痛苦，但计算机善于为我们避免这种痛苦。

### 乘积空间

两个集合`A`和`B`的乘积是所有偶对`(a, b)`的集合，其中`a ∈ A`和`b ∈ B`。 这个概念正是我们需要的，用于描述代表多个试验的空间。

例如，表示一枚硬币投掷结果的空间是 $Ω1 = {H，T}$。$Ω1$ 与其本身的乘积是偶对的集合`(H, H), (H, T), (T, H), (T, T)`，您可以认出这是硬币投掷的结果。 这个新空间和 $Ω1$ 的乘积是代表三次投掷的空间，以此类推。

Python 模块`itertools`包含构造乘积空间的函数`product`。 让我们导入它。

```py
from itertools import product
```

要了解`product`是如何工作的，我们将从投掷硬币的结果开始。我们正在使用`make_array`创建一个数组，但您可以使用任何其他方式创建数组或列表。

```py
one_toss = make_array('H', 'T')
```

为了使用`product`，我们必须指定基本空间和重复次数，然后将结果转换为列表。

```py
two_tosses = list(product(one_toss, repeat=2))
two_tosses

# [('H', 'H'), ('H', 'T'), ('T', 'H'), ('T', 'T')]
```

对于三次投掷，只需改变重复次数：

```py
three_tosses = list(product(one_toss, repeat=3))
three_tosses
'''
[('H', 'H', 'H'),
 ('H', 'H', 'T'),
 ('H', 'T', 'H'),
 ('H', 'T', 'T'),
 ('T', 'H', 'H'),
 ('T', 'H', 'T'),
 ('T', 'T', 'H'),
 ('T', 'T', 'T')]
'''
```

概率空间是结果空间，带有所有结果的概率。 如果假设三次投掷的八次结果是等可能的，则概率均为 1/8：

```py
three_toss_probs = (1/8)*np.ones(8)
```

相应的概率空间：

```py
three_toss_space = Table().with_columns(
    'omega', three_tosses,
    'P(omega)', three_toss_probs
)
three_toss_space
```


| omega | P(omega) |
| --- | --- |
| ['H' 'H' 'H'] | 0.125 |
| ['H' 'H' 'T'] | 0.125 |
| ['H' 'T' 'H'] | 0.125 |
| ['H' 'T' 'T'] | 0.125 |
| ['T' 'H' 'H'] | 0.125 |
| ['T' 'H' 'T'] | 0.125 |
| ['T' 'T' 'H'] | 0.125 |
| ['T' 'T' 'T'] | 0.125 |

乘积空间增长得非常快。 如果你投掷 5 次，将会有近 8000 种可能的结果：

```py
6**5
# 7776
```

但是我们有`product`，所以我们仍然可以列出所有乘积！ 这是一个表示 5 次骰子投掷的概率空间。

```py
die = np.arange(1, 7, 1)

five_rolls = list(product(die, repeat=5))  # All possible results of 5 rolls

five_roll_probs = (1/6**5)**np.ones(6**5)  # Each result has chance 1/6**5

five_roll_space = Table().with_columns(
   'omega', five_rolls,
    'P(omega)', five_roll_probs
)

five_roll_space
```

| omega | P(omega) |
| --- | --- |
| [1 1 1 1 1] | 0.000128601 |
| [1 1 1 1 2] | 0.000128601 |
| [1 1 1 1 3] | 0.000128601 |
| [1 1 1 1 4] | 0.000128601 |
| [1 1 1 1 5] | 0.000128601 |
| [1 1 1 1 6] | 0.000128601 |
| [1 1 1 2 1] | 0.000128601 |
| [1 1 1 2 2] | 0.000128601 |
| [1 1 1 2 3] | 0.000128601 |
| [1 1 1 2 4] | 0.000128601 |

... (7766 rows omitted)

### 结果空间上的函数

假设你投掷一个骰子五次，并将你看到的点数加起来。如果这看起来不清楚，请耐心等待一会儿，你很快就会明白为什么它很有趣。

点数的总和是五个点数的结果空间`Ω`上的数值函数。 总和是一个随机变量。我们称它为`S`。然后，在形式上，

$S: \Omega \rightarrow \{ 5, 6, \ldots, 30 \}$

`S`的范围是 5 到 30 的整数，因为每个骰子至少有一个点，最多六个点。 我们也可以使用相同的符号：

$\Omega \stackrel{S}{\rightarrow} \{ 5, 6, \ldots, 30 \}$

从计算的角度来看，`Ω`的元素位于`five_roll_space`的`omega`列中。让我们应用这个函数并创建一个更大的表格。

```py
five_rolls_sum = Table().with_columns(
    'omega', five_rolls,
    'S(omega)', five_roll_space.apply(sum, 'omega'),
    'P(omega)', five_roll_probs
)
five_rolls_sum
```

| omega | S(omega) | P(omega) |
| --- | --- | --- |
| [1 1 1 1 1] | 5 | 0.000128601 |
| [1 1 1 1 2] | 6 | 0.000128601 |
| [1 1 1 1 3] | 7 | 0.000128601 |
| [1 1 1 1 4] | 8 | 0.000128601 |
| [1 1 1 1 5] | 9 | 0.000128601 |
| [1 1 1 1 6] | 10 | 0.000128601 |
| [1 1 1 2 1] | 6 | 0.000128601 |
| [1 1 1 2 2] | 7 | 0.000128601 |
| [1 1 1 2 3] | 8 | 0.000128601 |
| [1 1 1 2 4] | 9 | 0.000128601 |

... (7766 rows omitted)

我们现在有五次投掷的所有可能的结果，以及它的总点数。您可以看到表格的第一行显示了尽可能少的点数，对应于所有投掷都显示 1 点。 第 7776 行显示了最大的：

```py
five_rolls_sum.take(7775)
```


| omega | S(omega) | P(omega) |
| --- | --- | --- |
| [6 6 6 6 6] | 30 | 0.000128601 |

`S`的所有其他值都在这两个极端之间。

#### 随机变量的函数

随机变量是`Ω`上的数值函数。 因此，通过复合，随机变量的数值函数也是随机变量。

例如，$S^2$ 是一个随机变量，计算如下：

$S^2(\omega) = \big{(} S(\omega)\big{)}^2$

所以 $S^2(\text{[6 6 6 6 6]}) = 30^2 = 900$。

### 由`S`确定的事件

从表`five_rolls_sum`中，很难判断有多少行显示 6 或 10 或其他任何值。 为了更好地理解`S`的属性，我们必须组织`five_rolls_sum`中的信息。

对于`S`中的任何子集`A`，定义事件`{S∈A}`为：

$\{S \in A \} = \{\omega: S(\omega) \in A \}$

在特殊情况下尝试这个定义。令`A = {5,30}`。 然后`{S∈A}`，当且仅当所有点数都是 1 点或 6 点。 所以：

$\{S \in A\} = \{\text{[1 1 1 1 1], [6 6 6 6 6]}\}$

询问总和是否为某个特定值的几率是很自然的，例如 10。读取表格并不容易，但我们可以访问相应的行：

```py
five_rolls_sum.where('S(omega)', are.equal_to(10))
```

... (116 rows omitted)

`S(ω)=10`的`ω`有 126 个值。由于所有的`ω`都相同，因此`S`的值为 10 的几率是 126/7776。

非正式情况下，我们通常会用符号表示，写成`{S = 10}`而不是`{S∈{10}}`。
